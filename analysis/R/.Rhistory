library(DMwR)
data(sales)
head(sales)
sales['Insp'==ok]
sales['Insp'=='ok']
sales[Insp=='ok']
mode(sales)
sales[sales$Insp=='ok']
sales[sales$Insp=='ok',]
length(sales[sales$Insp=='ok',])
length(sales[sales$Insp=='ok',"ID"])
length(sales[sales$Insp=='unkn',"ID"])
length(sales[sales$Insp=='fraud',"ID"])
summary(sales)
nlevels(sales$ID)
nlevels(sales$Prod)
head(is.na(sales$Quant))
which(is.na(sales$Quant))
sales[is.na(sales$Quant), "Quant"]
sales[is.na(sales$Quant), "ID"]
help(which)
which((1:10)==8)
which((1:10)>8)
which((10:1)>8)
table(sales$Insp)
table(sales$ID)
tots <- table(sales$ID)
totp <- table(sales$Prod)
barplot(tots, main="hello", xlab="sales", ylab="amount")
barplot(totp, main="hello", xlab="sales", ylab="amount")
boxplot(totp)
sales$Uprice <- sales$Val / sales$Quant
barplot(table(sales$Uprice))
length(table(sales$Uprice))
attach(sales)
upp <- aggregate(Uprice, list(Prod), median, na.rm=T)
list(Prod)
Prod
mode(Prod)
mode(list(Prod))
mode(1:10)
mode(list(1:10))
mode(Uprice)
list(rep(2,5))
topexpensive <- upp[order(upp[,2], decreasing=T)[1:5],1]
topexpensive
order(upp[,2])[1:5]
order(upp[,2])
help(order)
order(10:1)
order(1:10)
order(1:10,descreasing=T)
order(,decreasing=T)
help(order)
upp[1,1]
upp[1,1]
order(c(1,6,7,3),descreasing=T)
order(list(1,6,7,3),descreasing=T)
order(c(1,6,7,3),decreasing=T)
tops <- sales[Prod %in% topexpensive, c("Prod, "Uprice"")]
ls()
tops <- sales[Prod %in% topexpensive, c("Prod", "Uprice")]
nlevels(tops$Prod)
factor(tops$Prod)
nlevels(factor(tops$Prod))
tops$Prod <- (factor(tops$Prod))
boxplot(Uprice ~ Prod, data = tops)
head(sales)
vs <- aggregate(Val, list(ID), sum, na.rm=T)
head(vs)
topsales <- vs[order(vs$x, decreasing=T),]
head(topsales)
topsales <- vs[order(vs$x, decreasing=T)[1:5],]
head(topsales)
mode(topsales)
names(topsales)
topsales <- vs[order(vs$x, decreasing=T)[1:5],1]
mode(topsales)
head(topsales)
help(tapply)
puts("a")
print("a")
out <- tapply(Uprice, list(Prod=Prod), function(x) length(boxplot.stats(x)$out))
boxplot.stats(sales[sales$ID=='v431', Uprice])
boxplot.stats(sales[sales$ID=='v431', "Uprice"])
head(boxplot.stats(sales[sales$ID=='v431', "Uprice"]))
out <- tapply(Uprice, list(Prod=Prod), function(x) length(boxplot.stats(x)$out))
length(out)
head(out)
sum(out)
out <- tapply(Uprice, list(Prod), function(x) length(boxplot.stats(x)$out))
sum(out)
detach(sales)
table(sales)
table(sales$ID)
sales <- sales[-which(is.na(sales$Quant) & is.na(sales$Val)),]
nnasQp <- tapply(sales$Quant, list(sales$Prod), function(x) sum(is.na(x)))
propNAsQp <- nnasQp/table(sales$Prod)
sales <- sales[!sales$Prod %in% c("p2442","p2443"), ]
nlevels(sales$Prod)
sales$Prod <- factor(sales$Prod)
nlevels(sales$Prod)
quit()
install.packages('ROCR')
library(ROCR)
data(ROCR.simple)
mode(ROCR.simple$predictions)
help(prediction)
head(ROCR.simple$predictions)
head(ROCR.simple$labels)
pred <- predictions(ROCR.simple$predictions, ROCR.simple$labels)
pred <- prediction(ROCR.simple$predictions, ROCR.simple$labels)
head(pred)
mode(pred)
summary(pred)
plot(pref)
plot(pred)
perf <- performance(pred, "prec", "rec")
plot(perf)
help(performance)
quit()
help(split)
head(sales)
ups <- split(sales$Uprice, sales$Prod)
mode(ups)
ups
head(ups)
seq(along=ups)
ups[[1]]
head(ups)
ups$p1
ups[[1]]
r <- list()
r[[1]] <- 1:10
r
r[[1]] <- "hello"
r
r[[1]] <- 1:10
r[[2]] <- "hello"
r
help(holdOut)
??holdOut
load(DMwR)
library(DMwR)
head(sales)
help(holdOut)
library(stats)
help(hclust)
quit()
head(sales)
nb <- function(train, test){
require(e1071, quietly=T)
sup <- which(train$Insp != "unkn")
data <- train[sup, c("ID", "Prod", "Uprice", "Insp")]
data$Insp <- factor(data$Insp, levels=c("ok","fraud"))
model <- naiveBayes(Insp ~ ., data)
preds <- predict(model, test[, c("ID","Prod","Uprice","Insp")],type="raw")
return(list(rankOrder=order(preds[,"fraud"], decresing=T),rankScore=preds[,"fraud"]))
}
ho.nb <- function(form, train, test){
res <- nb(train, test)
structure(evalOutlierRanking(test,res$rankOrder,...),
itInfo=list(preds=res$rankScore,
trues=ifelse(test$Insp=='fraud',1,0)))}
nb.res <- holdOut(learner('ho.nb',
pars=list(Threshold=0.1,
statsProds=globalStats)),
dataset(Insp ~ .,sales),
hldSettings(3,0.3,1234,T),
itsInfo=TRUE
)
library(DMwR)
nb.res <- holdOut(learner('ho.nb',
pars=list(Threshold=0.1,
statsProds=globalStats)),
dataset(Insp ~ .,sales),
hldSettings(3,0.3,1234,T),
itsInfo=TRUE
)
install.packages('RWeka')
library(RWeka)
data(iris)
help(sample)
head(iris)
idx <- sample(150,100)
summary(idx)
head(idx)
mode(idx)
length(idx)
length(iris)
length(iris$Sepal.Length)
model <- AdaBoostM1(Species ~ ., iris[idx,],control=Weka_control(I=100))
preds <- predict(model,iris[-idx,])
head(preds)
levels(iris$Species)
prob.preds <- predict(model,iris[-idx,],type="probability")
head(prob.preds)
source("http://bioconductor.org/biocLite.R")
bioLite()
biocLite()
biocLite("ALL")
library(Biobase)
library(ALL)
data(ALL)
ALL
help(exprs)
source("http://bioconductor.org/bioLite.R")
source("http://bioconductor.org/biocLite.R")
bioLite("genefilter")
biocLite("genefilter")
tgt.cases <- which(ALL$BT %in% levels(ALL$BT)[1:5] & ALL$mol.bio %in% levels(ALL$mol.bio)[1:4])
ALLb <- ALL[,tgt.cases]
ALLb
featureName(ALL)[1:10]
featureNames(ALL)[1:10]
ALL
data(ALL)
ALL
install.packages('Hmisc')
library(ROCR)
help(resp)
help(ifelse)
help(ifelse)
help(ifelse)
help(resp)
help(anova)
help(Anova)
library(genefilter)
help(Anova)
install.packages('class')
quit()
install.packages("osmar")
library(osmar)
demo("navigator")
install.packages("sp")
library(sp)
install.packages("rgdal")
library(rgdal)
require(rgdal)
dsn
dsn="PG:dbname='beijing_taxi'"
ogrListLayers(dsn)
dsn="PG:dbname='beijing_taxi user=postgres'"
ogrListLayers(dsn)
dsn="PG:dbname=beijing_taxi user=postgres"
ogrListLayers(dsn)
dsn="PG:dbname=beijing_mm_po user=postgres"
ogrListLayers(dsn)
polys = readOGR(dsn=dsn,"geomtest")
dsn="PG:dbname=beijing_taxi user=postgres"
polys = readOGR(dsn=dsn,"geomtest")
summary(polys)
polys = readOGR(dsn=dsn,"taxi_tracks")
polys[0]
polys[0]
polys[1]
polys
polys = readOGR(dsn=dsn,"taxi_tracks")
summary(polys)
dsn="PG:dbname=beijing_taxi user=postgres"
ogrListLayers(dsn)
ogrListLayers(dsn)
quit()
source('path_statistics.r')
paths <- read.paths()
source('read_paths.r')
    print('reading paths')
    paths <- read.paths()
source('read_ways.r')
    print('reading ways and attrs')
    df.ways.attrs <- read.ways.attrs(c('id','used_times','km'))
ways.num <- length(df.ways.attrs$id)
    ways.used_times <- rep(0, ways.num)
    for(i in 1:ways.num) {
        ways.used_times[i] <- df.ways.attrs[df.ways.attrs$id == i, 'used_times']
    }
    ways.km <- rep(0, ways.num)
    for(i in 1:ways.num) {
        ways.km[i] <- df.ways.attrs[df.ways.attrs$id == i, 'km']
    }
ways.kmh <- rep(0, ways.num)
    for(i in 1:ways.num) {
        ways.kmh[i] <- df.ways.attrs[df.ways.attrs$id == i, 'kmh']
    }
df.ways.attrs <- read.ways.attrs(c('id','used_times','km','kmh'))
ways.kmh <- rep(0, ways.num)
    for(i in 1:ways.num) {
        ways.kmh[i] <- df.ways.attrs[df.ways.attrs$id == i, 'kmh']
    }
path2way.kmh <- function(p) {
    return(c(ways.kmh[p$ways]))
}
paths.used_timeses <- lapply(paths, path2way.used_times)
paths.lengths <- lapply(paths, path2way.km)
paths.speeds <- lapply(paths, path2way.kmh)
paths.norm.lengths <- lapply(paths.lengths, path2normlengths)
    paths.cum.lengths <- lapply(paths.lengths, path2cumlengths)
    paths.cum.norm.lengths <- lapply(paths.norm.lengths, path2cumlengths)
    paths.used_timeses.forplot <- lapply(paths.used_timeses, path2usedtimes_forplot)
avg.uts <- avg.path.ut()
plot.avg.uts(avg.uts)
paths.used_timeses <- paths.speeds
paths.used_timeses.forplot <- lapply(paths.used_timeses, path2usedtimes_forplot)
avg.uts <- avg.path.ut()
plot.avg.uts(avg.uts)
source('path_statistics.r')
paths.used_timeses <- lapply(paths, path2way.used_times)
paths.used_timeses.forplot <- lapply(paths.used_timeses, path2usedtimes_forplot)
avg.uts <- avg.path.ut()
plot.avg.uts(avg.uts)
source('path_statistics.r')
avg.uts <- avg.path.ut()
avg.path.ut <- function() {
    paths.num = length(paths)
    avg.uts <- rep(0, sn)
    for(i in 1:paths.num) {
        avg.uts <- avg.uts + sample.stairs(paths.cum.norm.lengths[[i]], paths.used_timeses.forplot[[i]], sp, sn, from)
    }
    return(avg.uts / paths.num)
}
avg.uts <- avg.path.ut()
plot.avg.uts(avg.uts)
import stats
library(stats)
library(signal)
install.packages('signal')
library(signal)
myfilter = butter(2, 0.1, type = 'low', plane='z')
yfiltered = signal:::filter(avg.uts, seq(sp,sp*sn,sp))
head(avg.uts)
freqz(myfilter)
yfiltered = signal:::filter(myfilter, avg.uts)
plot(seq(sp,sp*sn,sp),yfiltered,type='l')
plot.avg.uts(avg.uts)
pdf('avguts.pdf')
dev.list()
dev.set(2)
dev.copy(which=3)
dev.cur()
plot.avg.uts(avg.uts)
dev.list()
dev.cur()
plot.avg.uts(avg.uts)
dev.cur()
plot.avg.uts(avg.uts)
dev.set(2)
dev.copy(which=3)
dev.set(3)
dev.off()
dev.list()
pdf('avguts.pdf')
dev.cur()
plot.avg.uts(avg.uts)
dev.cur()
dev.cur()
plot.avg.uts(avg.uts)
dev.list()
dev.set(2)
dev.copy(which=3)
dev.set(3)
dev.off()
quit()
